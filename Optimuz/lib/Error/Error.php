<?php
/**
 * This file has a class for error handling, and is essential for the
 * application.
 * @version 0.4
 * @package Error
 */

/**
 * This is the framework default error object. All errors raised from classes
 * from Optimuz framework uses this class.
 *
 * It extends the PHP native Exception class.
 * @author Diego Andrade
 * @package Error
 * @since Optimuz 0.1
 * @version 0.4
 * @final
 * @static
 * @uses Lang
 * @uses Core.Enviroment
 * @uses Core.Load
 * @uses Core.Serial
 * @uses Application
 * @uses Configuration
 * @uses Log
 * @uses Error.Report
 * @uses Http.CurrentHttpRequest
 */
class Error extends Exception
{
	/**
	 * General error.
	 */
	const GENERAL_ERROR					= 1;

	/**
	 * This array stores all error objects generated during script execution.
	 * @var array
	 * @static
	 * @see Error::add()
	 * @see Error::getLast()
	 * @see Error::hasErrors()
	 */
	private static $list				= array();

	/**
	 * Indicates whether the error page is already being displayed to prevent it
	 * from being displayed multiple times.
	 * @var boolean
	 */
	protected static $showingErrorPage	= false;

	/**
	 * PHP error constants names.
	 * @var array
	 * @static
	 */
	private static $errorTypes			= array(
		1		=> "E_ERROR",
		2		=> "E_WARNING",
		4		=> "E_PARSE",
		8		=> "E_NOTICE",
		16		=> "E_CORE_ERROR",
		32		=> "E_CORE_WARNING",
		64		=> "E_COMPILE_ERROR",
		128		=> "E_COMPILE_WARNING",
		256		=> "E_USER_ERROR",
		512		=> "E_USER_WARNING",
		1024	=> "E_USER_NOTICE",
		2048	=> "E_STRICT",
		4096	=> "E_RECOVERABLE_ERROR",
		8192	=> "E_DEPRECATED",
		16384	=> "E_USER_DEPRECATED",
		30719	=> "E_ALL"
	);

	/**
	 * Position of the Error object on Error::$list.
	 * @var int
	 */
	protected $index						= null;

	/**
	 * Error's indentifyer. This is a serial number generated by the Serial
	 * class.
	 * @var string
	 */
	protected $uid						= null;

	/**
	 * Whether we caught a fatal error. If so, new exceptions cannot be thrown.
	 * @var bool
	 */
	protected static $hasFatalError		= false;

	/**
	 * Creates a new Error instance.
	 * @param mixed $msg It's a string with the error message, or an instance of
	 * the Exception class (or a subclass of it). If it is an object, the other
	 * parameters are ignored from the constructor and inherited from it.
	 * @param int $code (optional) Error code.
	 * @param int $line (optional) Error line.
	 * @param int $file (optional) Error file.
	 * @see Error::create()
	 * @see Error::add()
	 * @see Error::hasErrors()
	 */
	public function __construct($msg, $code = null, $line = null, $file = null)
	{
		if(is_object($msg) && $msg instanceof Exception)
		{
			parent::__construct($msg->message . "\n" . $msg->getTraceAsString(), $msg->code, $msg);
			$this->line = $msg->getLine();
			$this->file = $msg->getFile();
		}
		else
		{
			parent::__construct($msg, $code, null);
			$this->message = $msg;
			$this->code = $code;

			if(!empty($line))
				$this->line = $line;

			if(!empty($file))
				$this->file = $file;
		}

		$serial = new Serial(5, 2);
		$this->uid = $serial->generate();

		$this->index = count(self::$list);
		self::$list[] = $this;
	}

	/**
	 * Returns the error's identifyer. This identifyer is a serial number
	 * generated by the Serial class.
	 * @return string
	 */
	public function getUid()
	{
		return $this->uid;
	}

	/**
	 * Returns the error's index on the current list of errors.
	 * @return int
	 */
	public function getIndex()
	{
		return $this->index;
	}

	/**
	 * Returns the current error's list.
	 * @return array An array with the current Error objects.
	 * @static
	 */
	public static function getErrorsList()
	{
		return self::$list;
	}

	/**
	 * Returns a HTML error message.
	 * @return string
	 */
	public function getHtmlError()
	{
		return "<p><strong style='color:red'>{$this->code}: " . str_replace('&lt;', '<', str_replace('&gt;', '>', htmlentities($this->message, ENT_COMPAT, Text::detectEncoding($this->message)))) . '</strong></p>';
	}

	/**
	 * Returns the error stack as a string with HTML code.
	 *
	 * This only works for errors inherited from the Exception class.
	 * @return string
	 */
	public function getHtmlStack()
	{
		$str = $this->getTraceAsString();
		return str_replace('#', '<br />#', htmlentities($str, ENT_COMPAT, Text::detectEncoding($str)));
	}

	/**
	 * Returns the name of the class that generated the error.
	 * @return string
	 */
	public function getErrorType()
	{
		return get_class($this);
	}

	/**
	 * Returns the error information in the following pattern:
	 * ERROR_TYPE [ERROR_CODE]: {ERROR_UID} ERROR_MESSAGE.
	 * @return string
	 */
	public function __toString()
	{
		return "{$this->getErrorType()} [{$this->code}]: {{$this->uid}} {$this->message}";
	}

	/**
	 * Factory method: creates a new Error instance and returns it.
	 * @param string $msg Error message.
	 * @param int $code (optimal) Error code. Default is -1.
	 * @static
	 * @return Error
	 */
	public static function create($msg, $code = -1)
	{
		return new self($msg, $code);
	}

	/**
	 * Creates a new Error object and adds it to the error list.
	 * @param string $msg Error message.
	 * @param int $code (optimal) Error code. Default is -1.
	 * @see Error::$list
	 * @static
	 */
	public static function add($msg, $code = -1)
	{
		new self($msg, $code);
	}

	/**
	 * Returns the first error object from Error::$list.
	 * @return Error|false Returns an error object or false if the array is
	 * empty.
	 * @static
	 * @see Error::$list
	 */
	public static function getFirst()
	{
		return reset(self::$list);
	}

	/**
	 * Returns the last error object from Error::$list.
	 * @return Error|false Returns an error object or false if the array is
	 * empty.
	 * @static
	 * @see Error::$list
	 */
	public static function getLast()
	{
		return end(self::$list);
	}

	/**
	 * Checks for errors added to the list.
	 * @return bool
	 * @static
	 * @see Error::$list
	 */
	public static function hasErrors()
	{
		return count(self::$list) > 0;
	}

	/**
	 * Get the last script error. This will not return the last error object
	 * from Error::$list, but the last error from the PHP script.
	 *
	 * If there is no error, a null value will be returned.
	 * @return string|null
	 */
	public static function getScriptError()
	{
		$errorMsg = null;
		$errorInfo = error_get_last();

		if(!is_null($errorInfo))
		{
			$errorType = self::$errorTypes[$errorInfo['type']];
			$errorMsg = Language::getCurrent()->getSentence('error.scriptError', $errorType, $errorInfo['message'], $errorInfo['file'], $errorInfo['line']);
		}

		return $errorMsg;
	}

	/**
	 * This method is used to handle script errors. Like this, script erros can
	 * be handled as exceptions and catched in try/catch statements.
	 * @param string $errorNumber Number of the captured error.
	 * @param string $errorMessage Error message.
	 * @param string $errorFile File where the error occurred.
	 * @param int $errorLine Line where the error occurred.
	 * @static
	 */
	public static function handleScriptError($errorNumber, $errorMessage, $errorFile, $errorLine)
	{
		if(Buffer::isStarted())
			Buffer::clean();

		$error = new self($errorMessage);
		$error->code = $errorNumber;
		$error->file = $errorFile;
		$error->line = $errorLine;

		if(self::$hasFatalError ? Application::getCurrent() : false)
		{
			if(Application::getCurrent()->isListening('crash'))
			{
				Report::sendError($error);
				Application::getCurrent()->trigger('crash', array($error));
			}
			elseif(ThreadWorkerPool::getCurrentThread() ? ThreadWorkerPool::getCurrentThread()->isListening('crash') : false)
			{
				Report::sendError($error);
				ThreadWorkerPool::getCurrentThread()->trigger('crash', array($error));
			}
			else
			{
				self::handleOrThrow($error);
			}
		}
		else
		{
			self::handleOrThrow($error);
		}
	}

	/**
	 * This method is used to handle expceptions not caught.
	 * @param Exception $exception Exception object.
	 * @static
	 */
	public static function handleException(Exception $exception)
	{
		//$error = new self($exception->getMessage(), $exception->getCode());
		//self::$list[] = $exception;
		try
		{
			if(!Object::isType($exception, 'Error'))
				$error = Object::toType($exception, 'Error');
			else
				$error = $exception;
		}
		catch(Exception $ex)
		{
			$error = $exception;
		}

		if(Enviroment::isWebEnviroment() && LocalConfiguration::isLoaded())
			Report::sendError($error);
		else
			Log::add("{$error}\nLine {$error->getLine()}, file {$error->getFile()}, stacktrace:\n{$error->getTraceAsString()}", Log::ERROR);

		self::showStaticErrorPage();
	}

	/**
	 * This method is used to handle fatal errors. These kind of error cannot be
	 * handled by default error handlers, so we must catch'em here.
	 * @static
	 */
	public static function handleFatalError()
	{
		$lastError = error_get_last();

		if($lastError && isset(self::$errorTypes[$lastError['type']]))
		{
			switch(self::$errorTypes[$lastError['type']])
			{
				case 'E_ERROR':
				case 'E_PARSE':
				case 'E_CORE_ERROR':
				case 'E_CORE_WARNING':
				case 'E_COMPILE_ERROR':
				case 'E_COMPILE_WARNING':
				case 'E_STRICT':
					self::$hasFatalError = true;
					self::handleScriptError($lastError['type'], $lastError['message'], $lastError['file'], $lastError['line']);
					break;
			}
		}
	}

	/**
	 * Checks whether a fatal error was caught to make a decision: if we have a
	 * fatal error, we just handle it calling Error::showStaticErrorPage().
	 * Otherwise, the $error is thrown and the proper error handler will take
	 * care of it.
	 * @param Exception|Error $error Error object or any object that extends
	 * the class Exception.
	 */
	public static function handleOrThrow($error)
	{
		if(self::$hasFatalError)
		{
			Report::sendError($error);
			self::showStaticErrorPage();
		}
		else
		{
			throw $error;
		}
	}

	/**
	 * Shows the static error page.
	 *
	 * This is needed for circunstances when no application is available.
	 *
	 * The script execution is stopped right after calling this method.
	 * @static
	 */
	public static function showStaticErrorPage()
	{
		if(Enviroment::isWebEnviroment() && !self::$showingErrorPage)
		{
			self::$showingErrorPage = true;
			$charset = LocalConfiguration::get('page.charset');

			// if is an Ajax request we send an Ajax response
			if(class_exists('CurrentHttpRequest') && CurrentHttpRequest::getInstance()->isAjaxRequest())
			{
				$msg = Text::plain(Language::getInstance('Error')->getSentence('page.message'));
				$uid = Object::hasMethod(self::getFirst(), 'getUid') ? self::getFirst()->getUid() : null;
				$responseType = 'text/xml';
				$responseContent = "<?xml version='1.0' encoding='{$charset}'?" . ">\n<serverResponse><error>{$msg} ({$uid})</error></serverResponse>";
			}
			// otherwise we output the page
			else
			{
				$responseType = 'text/html';
				$responseContent = null;
			}

			try{
				// we send the header inside a try/catch to avoid "headers sent"
				// errors
				if(!headers_sent())
					header("Content-Type: {$responseType}; charset={$charset}", true, 500);
			}
			catch(Exception $ex){
			}

			Buffer::clean(true);

			if(is_null($responseContent))
				require Enviroment::getPath('apps') . 'system' . Enviroment::DIR_SEP . 'layers' . Enviroment::DIR_SEP . 'view' . Enviroment::DIR_SEP . 'page' . Enviroment::DIR_SEP . 'Error.php';
			else
				echo $responseContent;

			exit(0);
		}
	}
}
?>
